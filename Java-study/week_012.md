# 12주차 과제: 애노테이션

### 목표

자바의 애노테이션에 대해 학습하세요.

### 학습할 것 (필수)

- 애노테이션 정의하는 방법
- [@retention](https://github.com/retention)
- [@target](https://github.com/target)
- [@documented](https://github.com/documented)
- 애노테이션 프로세서



## 애노테이션

주석처럼 프로그래밍 언어에 영향을 미치지 않으며 유용한 정보(설정 정보)를 특정 프로그램에게 제공하는 것

예전에는 현업에서 프로그램을 작성할 경우 소스코드와 설정파일(예: .xml)을 분리하여 관리했었다고 한다. 그런데 소스코드를 여러사람이 공유해야 하는 점과 소스코드가 변경될 때마다 설정파일도 동시에 변경해야하는 번거로움과 버전 불일치 등의 문제가 빈번하였는데, 이를 합치기로 하면서 애노테이션이 생겼다고 한다.

애노테이션은 코드에 설정에 대한 정보를 넣기로 한 것이며, 기존 문법을 바꾸지 않아도 되는 장점이 있다. 

사용 예) ``@Test`` 라는 어노테이션의 경우 ``JUnit``이라는 특정 프로그램에서만 유효하며, 테스트 대상이 될 메소드에 이 애노테이션 하나만 추가하면 따로 테스트 될 대상을 지정해주지 않아도 된다.

또한, 예를 들어 스프링의 경우 스프링 컨테이너에게 관리할 대상인 빈에 대한 정보를 XML 파일(``application.xml``)로 작성였는데 지금은 자바코드로 설정파일을 만들어 ``@Bean``이라는 애노테이션을 사용하여 쉽게 빈을 관리할 수 있다.

설정파일의 경우 함부로 수정할 수 없는 것





소스코드 + 소스코드 프로그램에 대한 문서-> 버전문제 때문에 관리를 용이하게 하기 위해 주석으로 바뀌게 됨

``/* .... */ `` : Javadoc 주석(Javac.exe를 위한 주석)



### 표준 애노테이션

Java에서 제공하는 애노테이션



**1) @Override**

오버라이딩을 올바르게 했는지 컴파일러가 체크, javac.exe가 사용하는 애노테이션

오버라이딩을 할 때 메서드 이름을 잘못 적는 실수를 하는 경우가 많음

![image-20210201234024221](week_012.assets/image-20210201234024221.png)

이런 실수를 방지하고자 나온 애노테이션으로, 오버라이딩할 때는 메서드 선언부 앞에 @Override를 붙이면 된다.

이렇게 하면 컴파일 단계에서 오류가 발생하기 때문에 오타 여부를 쉽게 파악할 수 있다. 그래서 메서드 상속 시 이 애노테이션을 붙이는 습관을 들이는 것이 좋다.



**2) @Deprecated**

앞으로 사용하지 않을 것을 권장하는 필드나 메서드를 표시하는 용도로 쓰임

![image-20210201234052576](week_012.assets/image-20210201234052576.png)

자바는 하위호환성을 중요시 여겨서 구 버전의 메서드를 없애지는 않으나, 사용을 권장하지 않는다는 표시로 이 애노테이션을 사용한다.

해당 어노테이션이 붙은 메서드를 사용하여 코드를 컴파일할 경우 다음과 같은 메시지가 나타나는 것을 확인할 수 있다.

![image-20210201234526559](week_012.assets/image-20210201234526559.png)



**3) FunctionalInterface**

함수형 인터페이스에 붙이는 애노테이션으로, 이 인터페이스가 제대로 작성(함수형 인터페이스는 하나의 추상메서드만 가져야 함)이 되었는지 컴파일러가 체크하는 용도로 사용됨

![image-20210201232534517](week_012.assets/image-20210201232534517.png)



**4) SuppressWarnings**

컴파일러의 경고메시지가 나타나지 않게 억제하는 용도로 사용하는 애노테이션

괄호() 안에 억제하고자하는 경고의 종류를 문자열로 지정하여 사용하며, 다음과 같은 방식으로 작성하면 된다.

![image-20210201232956994](week_012.assets/image-20210201232956994.png)



컴파일러가 알려주는 경고를 코드작성자가 이미 파악하여 확인했다는 표시의 의미로 사용됨

둘 이상의 경고를 동시에 억제하려면 괄호 안에 중괄호{}를 사용하여 경고의 종류를 배열 선언하는 것처럼 나열해주면 됨

그리고 `` -Xlint`` 옵션으로 컴파일하면, 경고메시지를 확인할 수 있음

![image-20210201233432277](week_012.assets/image-20210201233432277.png)

대괄호 안에 있는 내용이 경고의 종류임

확인된 경고는 SuppressWarnings 애노테이션을 사용하여 경고를 억제해야, 다음에 발생할 수 있는 새로운 경고를 확인할 수 있기 때문에 이 애노테이션의 사용도 습관을 들이는 것이 좋다.





메타 애노테이션: 애노테이션을 만들 때 사용



### Reference URL

> https://youtube.com/playlist?list=PLW2UjW795-f6xWA2_MUhEVgPauhGl3xIp