# 14주차 과제: 제네릭

### 목표

자바의 제네릭에 대해 학습하세요.

### 학습할 것 (필수)

- 제네릭 사용법
- 제네릭 주요 개념 (바운디드 타입, 와일드 카드)
- 제네릭 메소드 만들기
- Erasure



## Generics

컴파일러에게 타입 정보를 제공함으로써, 컴파일시 타입을 체크해주는 기능이며 JDK 1.5부터 도입되었다.

제네릭은 객체의 **타입 안정성**을 높이고 **형변환 생략이 가능**해 코드가 간결해지는 장점을 갖고 있다.

면밀히 말하자면, 제네릭은 런타임 에러인 ``ClassCastException`` (형변환에러) 예외를 컴파일 에러로 잡아내고자 고안된 기능이다. 다음 코드를 보자.

![image-20210226225429957](week_014_Generic.assets/image-20210226225429957.png)

정수를 추가할 list를 하나 만들었다고 하자. 그런데, 실수로 정수가 아닌 ``String``을 추가하게 되었다. 

당연히 정수가 들어있을 줄 알고 list에서 요소를 꺼내 ``Integer`` 타입으로 형변환을 시도한다고 하면 다음과 같은 런타임 에러인 ``ClassCastException`` 을 맞이하게 되는 것이다.

![image-20210226225001779](week_014_Generic.assets/image-20210226225001779.png)

컴파일러는 당연히 ``list.get()``을 호출하면 반환하는 타입이 ``Object``이기 때문에 ``Object`` 타입을 ``Integer``로 변환하는 것이 문제가 되지 않기 때문에 에러로 잡지 않는다.

하지만 실제로 들어있는 것은 ``String``타입이기 때문에 형변환 에러가 발생하는 것이다.

제네릭을 사용하여 이전의 코드를 다음과 같이 수정하였다.

![image-20210226230739630](week_014_Generic.assets/image-20210226230739630.png)

list에 들어갈 요소의 타입을 맨 윗줄의 코드와 같이 ``Integer``로 지정해주면 실수로 ``String``을 추가하게 되더라도 컴파일러가 체크해주는 것을 확인할 수 있다. 

또한 list의 타입을 알고 있기 때문에 ``list.get()``을 할 때 형변환 생략이 가능하여 다음과 같이 바꿔서 쓸 수 있다.

```java
// Integer i = (Integer) list.get(2); 
Integer i = list.get(2);
```



### 타입 변수

제네릭 클래스를 작성할 때, 일반 클래스의 ``Object``타입 대신 타입 변수(E)를 선언해서 사용

통상적으로 대문자 한글자를 사용하며, 보통 Type을 의미하는 T나 Element의 E를 주로 사용한다.

![image-20210226232707504](week_014_Generic.assets/image-20210226232707504.png)

객체를 생성할 때, 타입 변수(E) 대신 실제 타입을 지정해줘야 한다. 타입 변수의 타입은 참조변수와 생성자에 넣어줘야 하며, 이 둘의 타입이 일치해야 한다. 

```java
ArrayList<Integer> list = new ArrayList<Integer>();
```

JDK 1.7부터는 생성자에 타입을 지정하는 것을 생략할 수 있어 다음과 같이 쓸 수 있다.

```java
ArrayList<Integer> list = new ArrayList<>();
```



